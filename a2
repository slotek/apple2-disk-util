#!/usr/bin/env ruby
#
# Apple II DOS 3.3 disk image utility
# Copyright (C) 2017 slotek@nym.hush.com
#
require 'gli'
require 'set'
require 'delegate'

# ---------- Apple 2 Utility ----------

module Apple2
  #
  # Apple 2 String class
  #
  # Apple 2 to ASCII character map:
  #   00-1f => 40-5f inverse uppercase alpha
  #   20-3f => 20-3f inverse symbols
  #   40-5f => 40-5f flashing uppercase alpha
  #   60-7f => 20-3f flashing symbols
  #   80-ff => 00-7f standard ascii chars
  #
  class Apple2String < SimpleDelegator
    def self.to_ascii(c)
      if (c >= 0 && c <= 0x1f)
        c += 0x40
      elsif (c >= 0x60 && c <= 0x7f)
        c -= 0x40
      elsif (c >= 0x80)
        c -= 0x80
      end
      return c
    end

    def self.parse(buffer)
      str = Apple2String.new
      buffer.each_byte { |c| str << self.to_ascii(c) }
      str
    end

    def initialize(str = "")
      super(str)
    end

    def to_buffer
      buffer = String.new
      each_byte { |c| buffer << (c | 0x80) }
      buffer
    end
  end

  class Disk
    def self.catalog(dsk)
      puts "#{dsk}:"
      Apple2::Disk.new(dsk).catalog.file_entries.each { |f| puts f.to_s }
      puts
    end

    class FileInfo
      attr_reader :num_tsl_sectors, :num_data_sectors, :num_sectors

      def initialize(data)
        @num_tsl_sectors = (data.length / BYTES_PER_TSL_SECTOR) + ((data.length % BYTES_PER_TSL_SECTOR > 0) ? 1 : 0)
        @num_data_sectors = data.length / BYTES_PER_SECTOR   # FIXME: assume no remainder
        @num_sectors = @num_data_sectors + @num_tsl_sectors
      end
    end

    TRACKS_PER_DISK           = 35
    SECTORS_PER_TRACK         = 16
    BYTES_PER_SECTOR          = 256
    BYTES_PER_TRACK           = SECTORS_PER_TRACK * BYTES_PER_SECTOR
    BYTES_PER_DISK            = TRACKS_PER_DISK * BYTES_PER_TRACK
    TRACK_SECTOR_LIST_OFFSET  = 0xc
    LINKS_PER_TSL_SECTOR      = 122
    BYTES_PER_TSL_SECTOR      = LINKS_PER_TSL_SECTOR * BYTES_PER_SECTOR
    TSL_LINK_OFFSET           = 0xc
    TSL_SECTOR_NUM_OFFSET     = 5

    attr_reader :catalog

    def self.valid_ts?(track, sector)
      track >= 0 && track < Disk::TRACKS_PER_DISK && sector >= 0 && sector < Disk::SECTORS_PER_TRACK
    end

    def initialize(filename)
      @filename = filename
      File.open(@filename, "rb") { |f| @buf = f.read }
      @vtoc = VTOC.new(self)
      @catalog = Catalog.new(self, @vtoc.catalog_track, @vtoc.catalog_sector)
    end

    def valid?
      ((BYTES_PER_DISK - @buf.length).abs < BYTES_PER_SECTOR) && @vtoc.valid?
    end

    def read_byte(track, sector, byte = 0)
      @buf[to_offset(track, sector, byte)].unpack("C").first
    end

    def read_bytes(track, sector, byte = 0, length = BYTES_PER_SECTOR)
      if length > 0 && (byte + length <= BYTES_PER_SECTOR)
        return @buf[to_offset(track, sector, byte), length]
      else
        raise "Cannot read #{length} bytes from offset #{byte}"
      end
    end

    def write_bytes(track, sector, byte, src)
      if src.length > 0 && (byte + src.length <= BYTES_PER_SECTOR)
        i = to_offset(track, sector, byte)
        src.each_char do |c|
          @buf[i] = c
          i += 1
        end
      else
        raise "Cannot write #{src.length} bytes at offset #{byte}"
      end
    end

    def read_file(file_entry)
      filebuf = ""
      get_ts_list(file_entry).each do |t, s|
        filebuf << read_bytes(t, s)
      end
      filebuf
    end

    def write_file(filename, type, data)
      file_info = FileInfo.new(data)

      vtoc_free_sectors = @vtoc.free_sectors
      if file_info.num_sectors > vtoc_free_sectors.length
        raise sprintf("Insufficient space. Free sectors: %d, file sectors: %d\n",
                      vtoc_free_sectors.length, file_info.num_sectors)
      end

      free_sectors = vtoc_free_sectors.each

      tsl_sectors = []
      last_track_written = 0
      file_info.num_data_sectors.times do |d|
        # Allocate TSL sector if necessary
        if d % LINKS_PER_TSL_SECTOR == 0
          tsl_sectors << @vtoc.alloc(free_sectors.next)
          #printf("%p tsl\n", tsl_sectors.last)
        end

        # Allocate and write data sector
        data_sector = @vtoc.alloc(free_sectors.next)
        write_file_data_sector(data_sector, d, data)
        last_track_written = data_sector[0]

        # Write link to TSL sector
        write_file_link(tsl_sectors.last, tsl_sectors.index(tsl_sectors.last), data_sector, d % LINKS_PER_TSL_SECTOR)
      end

      # Update links between tsl sectors
      for tsl_sector_index in (0...tsl_sectors.length-1)
        t, s = tsl_sectors[tsl_sector_index]
        write_bytes(t, s, 1, tsl_sectors[tsl_sector_index + 1].pack("CC"))
      end

      @vtoc.set_last_allocated_track(last_track_written)

      @catalog.add_file_entry(filename, type, file_info.num_sectors, tsl_sectors[0][0],
                              tsl_sectors[0][1])
    end

    def write
      File.open(@filename, "wb") { |f| f << @buf }
    end

    private

    def to_offset(track, sector, byte = 0)
      if track >= 0 && track < TRACKS_PER_DISK && sector >= 0 && sector < SECTORS_PER_TRACK && byte >= 0 && byte < BYTES_PER_SECTOR
        return track * BYTES_PER_TRACK + sector * BYTES_PER_SECTOR + byte
      else
        raise sprintf("Invalid offset: track %02x, sector %02x, byte %02x", track, sector, byte)
      end
    end

    def get_ts_list(file_entry)
      ts_list = []
      t = file_entry.ts_list_track
      s = file_entry.ts_list_sector
      while (t > 0 && t < TRACKS_PER_DISK)
        TRACK_SECTOR_LIST_OFFSET.step(BYTES_PER_SECTOR-1, 2) do |i|
          ts = read_bytes(t, s, i, 2).unpack("CC")
          break if ts[0] == 0
          ts_list << ts
        end
        t, s = read_bytes(t, s, 1, 2).unpack("CC")
      end
      ts_list
    end

    def write_file_data_sector(data_ts, index, data)
      #printf("%p data index %d, ", data_ts, index)
      write_bytes(data_ts[0], data_ts[1], 0, data[index * BYTES_PER_SECTOR, BYTES_PER_SECTOR])
    end

    def write_file_link(tsl_ts, tsl_sector_index, link_ts, link_index)
      #printf("tsl %p, link %d = %p\n", tsl_ts, link_index, link_ts)
      write_bytes(tsl_ts[0], tsl_ts[1], TSL_SECTOR_NUM_OFFSET,
                  [tsl_sector_index * LINKS_PER_TSL_SECTOR].pack("v"))
      write_bytes(tsl_ts[0], tsl_ts[1], 2 * link_index + TSL_LINK_OFFSET, link_ts.pack("CC"))
    end
  end

  class VTOC
    class Bitmap
      BITMAP_LENGTH = 2

      def initialize(disk, track)
        @disk = disk
        @track = track
        @offset = VTOC::TRACK_BITMAP_OFFSET + (track * BITMAP_LENGTH * 2)
      end

      def alloc(sector)
        write_bitmap(read_bitmap & ~(1 << sector))
      end

      def free(sector)
        write_bitmap(read_bitmap | (1 << sector))
      end

      def free?(sector)
        (read_bitmap & (1 << sector)) != 0
      end

      private

      def read_bitmap
        @disk.read_bytes(VTOC::VTOC_TRACK, VTOC::VTOC_SECTOR, @offset, BITMAP_LENGTH).unpack("n").first
      end

      def write_bitmap(bmp)
        @disk.write_bytes(VTOC::VTOC_TRACK, VTOC::VTOC_SECTOR, @offset, [bmp].pack("n"))
      end
    end

    VTOC_TRACK                = 0x11
    VTOC_SECTOR               = 0
    CATALOG_TRACK_OFFSET      = 1
    CATALOG_SECTOR_OFFSET     = 2
    SECTORS_PER_TRACK_OFFSET  = 0x35
    TRACK_BITMAP_OFFSET       = 0x38
    LAST_ALLOCATED_TRACK_OFFSET = 0x30
    ALLOCATION_DIRECTION_OFFSET = 0x31

    def initialize(disk)
      @disk = disk
    end

    def valid?
      @disk.read_byte(VTOC_TRACK, VTOC_SECTOR, SECTORS_PER_TRACK_OFFSET) == Disk::SECTORS_PER_TRACK
    end

    def catalog_track
      @disk.read_byte(VTOC_TRACK, VTOC_SECTOR, CATALOG_TRACK_OFFSET)
    end

    def catalog_sector
      @disk.read_byte(VTOC_TRACK, VTOC_SECTOR, CATALOG_SECTOR_OFFSET)
    end

    def alloc(track_sector)
      t, s = track_sector
      Bitmap.new(@disk, t).alloc(s) if Disk::valid_ts?(t, s)
      track_sector
    end

    def free(track, sector)
      Bitmap.new(@disk, track).free(sector) if Disk::valid_ts?(track, sector)
    end

    def free?(track, sector)
      Disk::valid_ts?(track, sector) ? Bitmap.new(@disk, track).free?(sector) : false
    end

    def last_allocated_track
      @disk.read_byte(VTOC_TRACK, VTOC_SECTOR, LAST_ALLOCATED_TRACK_OFFSET)
    end

    def set_last_allocated_track(track)
      @disk.write_bytes(VTOC_TRACK, VTOC_SECTOR, LAST_ALLOCATED_TRACK_OFFSET, [track].pack("C"))
      set_allocation_direction(track)
    end

    def allocation_direction
      @disk.read_byte(VTOC_TRACK, VTOC_SECTOR, ALLOCATION_DIRECTION_OFFSET) == 1 ? 1 : -1
    end

    # Return list of free [track, sector] pairs as ordered
    # by the DOS 3.3 file allocation strategy.
    def free_sectors
      free = []
      direction = allocation_direction
        
      t = last_allocated_track + direction
      s = 0xf

      loop do
        free << [t, s] if free?(t, s)

        break if t == 0 && s == 0

        # Adjust track & sector
        if s > 0
          s -= 1
        else
          s = 0xf
          t += direction
          if t > 0x22
            t = 0x10
            direction = -1
          elsif t < 0
            t = 0x11
            direction = 1
          end
        end
      end

      free
    end

    private

    def set_allocation_direction(track)
      d = track >= 0x11 ? 1 : 0xff
      @disk.write_bytes(VTOC_TRACK, VTOC_SECTOR, ALLOCATION_DIRECTION_OFFSET, [d].pack("C"))
    end
  end

  class Catalog
    FILE_ENTRY_OFFSETS  = [0xb, 0x2e, 0x51, 0x74, 0x97, 0xba, 0xdd]
    FILE_ENTRY_LENGTH   = 0x23

    attr_reader :file_entries

    def self.valid_ts?(track, sector)
      track > 0 && track < Disk::TRACKS_PER_DISK && sector > 0 && sector < Disk::SECTORS_PER_TRACK
    end

    def initialize(disk, track, sector)
      @disk = disk
      @file_entries = []
      @catalog_track = track
      @catalog_sector = sector

      # Parse files from catalog sectors
      if disk.valid?
        visited = Set.new
        found_empty = false
        while Catalog.valid_ts?(track, sector) && !found_empty && !visited.include?([track, sector])
          FILE_ENTRY_OFFSETS.each do |i|
            entry = FileEntry.parse(@disk.read_bytes(track, sector, i, FILE_ENTRY_LENGTH))
            if entry.empty?
              found_empty = true
            elsif !entry.deleted?
              @file_entries << entry
            end
          end
          visited << [track, sector]
          track, sector = @disk.read_bytes(track, sector, 1, 2).unpack("CC")
        end
      end
    end

    def add_file_entry(name, type, length, ts_list_track, ts_list_sector)
      done = false
      track = @catalog_track
      sector = @catalog_sector
      while Catalog.valid_ts?(track, sector) && !done
        FILE_ENTRY_OFFSETS.each do |i|
          entry = FileEntry.parse(@disk.read_bytes(track, sector, i, FILE_ENTRY_LENGTH))
          if entry.empty? || entry.deleted?
            new_entry = FileEntry.new(name, type, length, ts_list_track, ts_list_sector)
            @file_entries << new_entry
            @disk.write_bytes(track, sector, i, new_entry.to_buffer)
            done = true
            break
          end
        end
        track, sector = @disk.read_bytes(track, sector, 1, 2).unpack("CC")
      end
    end
  end

  class FileEntry
    FILE_NAME_LENGTH = 30
    FILE_TYPES = {
      0 => "T",
      1 => "I",
      2 => "A",
      4 => "B",
      8 => "S",
      0x10 => "R",
      0x20 => "a",
      0x40 => "b"
    }

    attr_reader :name, :length, :ts_list_track, :ts_list_sector, :flags

    def self.parse(buf)
      ts_list_track, ts_list_sector = buf[0, 2].unpack("CC")
      flags = buf[2].unpack("C").first
      name = Apple2String.parse(buf[3, FILE_NAME_LENGTH])
      length = buf[0x21, 2].unpack("v").first
      FileEntry.new(name, flags, length, ts_list_track, ts_list_sector)
    end

    def initialize(name, flags, length, ts_list_track, ts_list_sector)
      @name = Apple2String.new(name[0, FILE_NAME_LENGTH])
      if name.length < FILE_NAME_LENGTH
        @name << ' ' * (FILE_NAME_LENGTH - name.length)
      end
      @flags = flags
      @length = length
      @ts_list_track = ts_list_track
      @ts_list_sector = ts_list_sector
    end

    def to_buffer
      buf = [@ts_list_track, @ts_list_sector, @flags].pack("C*")
      buf << @name.to_buffer
      buf << [@length].pack("v")
    end

    def empty?
      @ts_list_track == 0 && @ts_list_sector == 0
    end

    def deleted?
      @ts_list_track == 0xff
    end

    def locked?
      @flags & 0x80
    end

    def type
      FILE_TYPES.fetch(@flags & 0x7f, "?")
    end

    def to_s
      str = locked? ? "*" : " "
      str << type << " "
      str << sprintf("%03d", length) << " "
      str << name
      str
    end
  end
end

# ---------- GLI command line application ----------

include GLI::App
include Apple2

program_desc 'Apple II Disk Image Utility'
version '0.2.2'

subcommand_option_handling :normal
arguments :strict

# Catalog command
desc 'Display contents of specified Apple II disk image(s)'
long_desc """
Display the Apple II DOS 3.3 catalog information for the specified
path arguments. Each path argument is either a directory, DSK, or DO
file image name. If no arguments are given, catalog info is displayed
for each disk image found in the current directory.
"""

arg_name '[path...]'
command [:catalog, :ls] do |c|
  c.desc 'Recursively search each specified directory'
  c.switch [:R, :recurse]

  c.action do |global_options,options,args|
    args << "." if args.empty?
    args.each do |path|
      if Dir.exists?(path)
        dir = path
        dir << "/**" if options[:recurse]
        dir << "/*.{do,dsk}"
        Dir.glob(dir, File::FNM_CASEFOLD).sort.each do |dsk|
          Disk.catalog(dsk)
        end
      elsif File.exist?(path)
        Disk.catalog(path)
      end
    end
  end
end

# Copy command
desc 'Copy a DOS 3.3 file from one disk image to another'
arg_name 'src_file src_disk dest_disk'
command [:copy, :cp] do |c|
  c.desc 'Verbose mode'
  c.switch [:v, :verbose]

  c.flag [:d, :destination],
    :arg_name => 'file',
    :desc => 'Destination file name'

  c.action do |global_options,options,args|
    src_file_name = args.shift
    src_disk_name = args.shift
    dest_disk_name = args.shift
    dest_file_name = options[:destination] ||= src_file_name

    raise "Source file not specified" if !src_file_name
    raise "Source disk not specified" if !src_disk_name
    raise "Destination disk not specified" if !dest_disk_name
    raise "Too many copy command arguments" if args.length > 0

    if options[:verbose]
      printf("Copying file \"%s\" from disk \"%s\" to file \"%s\" on disk \"%s\"\n",
             src_file_name, src_disk_name,
             dest_file_name, dest_disk_name)
    end

    #TODO: file_entries[filename], file_exists?
    #TODO: verify dest disk exists and is dos disk
    #TODO: verify dest file name does not already exist
    found = false
    src_disk = Disk.new(src_disk_name)
    src_disk.catalog.file_entries.each do |f|
      if (src_file_name == f.name.strip)
        dest_disk = Disk.new(dest_disk_name)
        dest_disk.write_file(dest_file_name, f.flags, src_disk.read_file(f))
        dest_disk.write
        found = true
        break
      end
    end

    if (!found)
      raise "File not found: \"#{src_file_name}\""
    end
  end
end

# Pre command execution hook
pre do |global,command,options,args|
  # Return false to abort command execution
  true
end

# Post command execution hook
post do |global,command,options,args|
  # Post logic here
end

# Error handler
on_error do |exception|
  # Return false to skip default error handling
  true
end

# Run the application
exit run(ARGV)
